name: Vault Secret Management

on:
  workflow_call:
    inputs:
      update_secrets:
        description: 'Update secrets in Vault'
        required: false
        default: false
        type: boolean
  workflow_dispatch:
    inputs:
      action:
        description: 'Vault action to perform'
        required: true
        default: 'sync-secrets'
        type: choice
        options:
        - sync-secrets
        - rotate-github-runner-token
        - validate-secrets

permissions:
  contents: read

env:
  VAULT_ADDR: ${{ secrets.VAULT_ADDR || 'http://localhost:8200' }}

jobs:
  vault-auth:
    name: Authenticate with Vault
    runs-on: self-hosted
    timeout-minutes: 5
    permissions:
      contents: read
    
    outputs:
      vault-token: ${{ steps.auth.outputs.token }}
      
    steps:
    - name: Install Vault CLI
      run: |
        if ! command -v vault &> /dev/null; then
          echo "Installing Vault CLI..."
          curl -fsSL https://releases.hashicorp.com/vault/1.15.4/vault_1.15.4_linux_amd64.zip -o /tmp/vault.zip
          unzip -o /tmp/vault.zip -d /tmp/
          sudo mv /tmp/vault /usr/local/bin/
          chmod +x /usr/local/bin/vault
          rm /tmp/vault.zip
        fi
        
        vault version
    
    - name: Authenticate with Vault
      id: auth
      run: |
        echo "Authenticating with Vault using AppRole..."
        
        # Authenticate using AppRole
        response=$(vault write -format=json auth/approle/login \
          role_id="${{ secrets.VAULT_ROLE_ID }}" \
          secret_id="${{ secrets.VAULT_SECRET_ID }}")
        
        token=$(echo "$response" | jq -r '.auth.client_token')
        
        if [[ "$token" == "null" || -z "$token" ]]; then
          echo "Failed to authenticate with Vault"
          exit 1
        fi
        
        # Set token for subsequent steps
        echo "VAULT_TOKEN=$token" >> $GITHUB_ENV
        echo "token=$token" >> $GITHUB_OUTPUT
        
        echo "Successfully authenticated with Vault"

  sync-secrets:
    name: Sync Secrets from Vault
    runs-on: self-hosted
    timeout-minutes: 10
    permissions:
      contents: read
    needs: vault-auth
    if: github.event.inputs.action == 'sync-secrets' || github.event.inputs.action == ''
    
    steps:
    - name: Checkout Repository  
      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
      with:
        persist-credentials: false
    
    - name: Generate .env from Vault
      env:
        VAULT_TOKEN: ${{ needs.vault-auth.outputs.vault-token }}
      run: |
        echo "Fetching secrets from Vault..."
        
        # Create .env file from Vault secrets
        cat > .env << 'EOF'
        # Generated from Vault secrets - $(date)
        
        # Basic Configuration
        TZ=$(vault kv get -field=TZ kv/homeserver/config)
        PUID=$(vault kv get -field=PUID kv/homeserver/config)
        PGID=$(vault kv get -field=PGID kv/homeserver/config)
        
        # Domain Configuration  
        DOMAIN=$(vault kv get -field=DOMAIN kv/homeserver/config)
        
        # Storage Paths
        NVME_PATH=$(vault kv get -field=NVME_PATH kv/homeserver/config)
        SSD_PATH=$(vault kv get -field=SSD_PATH kv/homeserver/config)  
        HDD_PATH=$(vault kv get -field=HDD_PATH kv/homeserver/config)
        
        # Cloudflare Secrets
        CLOUDFLARE_API_TOKEN=$(vault kv get -field=api_token kv/homeserver/cloudflare)
        CLOUDFLARE_ZONE_ID=$(vault kv get -field=zone_id kv/homeserver/cloudflare)
        CLOUDFLARE_EMAIL=$(vault kv get -field=email kv/homeserver/cloudflare)
        
        # Database Secrets
        MYSQL_ROOT_PASSWORD=$(vault kv get -field=mysql_root_password kv/homeserver/database)
        REDIS_PASSWORD=$(vault kv get -field=redis_password kv/homeserver/database)
        MONITORING_DB_PASSWORD=$(vault kv get -field=monitoring_password kv/homeserver/database)
        BACKUP_DB_PASSWORD=$(vault kv get -field=backup_password kv/homeserver/database)
        
        # Service Authentication
        GF_SECURITY_ADMIN_PASSWORD=$(vault kv get -field=grafana_password kv/homeserver/services)
        QBITTORRENT_PASSWORD=$(vault kv get -field=qbittorrent_password kv/homeserver/services)
        PLEX_CLAIM=$(vault kv get -field=plex_claim kv/homeserver/services)
        
        # Authelia Secrets
        AUTHELIA_JWT_SECRET=$(vault kv get -field=jwt_secret kv/homeserver/authelia)
        AUTHELIA_SESSION_SECRET=$(vault kv get -field=session_secret kv/homeserver/authelia)
        AUTHELIA_STORAGE_ENCRYPTION_KEY=$(vault kv get -field=storage_key kv/homeserver/authelia)
        
        # Gaming Services
        CS2_SERVER_NAME=$(vault kv get -field=cs2_server_name kv/homeserver/gaming)
        CS2_RCON_PASSWORD=$(vault kv get -field=cs2_rcon_password kv/homeserver/gaming)  
        CS2_SERVER_PASSWORD=$(vault kv get -field=cs2_server_password kv/homeserver/gaming)
        STEAM_TOKEN=$(vault kv get -field=steam_token kv/homeserver/gaming)
        TS3_SERVER_ADMIN_PASSWORD=$(vault kv get -field=ts3_admin_password kv/homeserver/gaming)
        
        # Notification Settings
        DISCORD_WEBHOOK_URL=$(vault kv get -field=discord_webhook kv/homeserver/notifications)
        
        # Backup Configuration
        BACKUP_ENCRYPTION_KEY=$(vault kv get -field=encryption_key kv/homeserver/backup)
        B2_ACCOUNT_ID=$(vault kv get -field=b2_account_id kv/homeserver/backup)
        B2_ACCOUNT_KEY=$(vault kv get -field=b2_account_key kv/homeserver/backup)
        B2_BUCKET_NAME=$(vault kv get -field=b2_bucket_name kv/homeserver/backup)
        
        # GitHub Actions Runner
        GITHUB_REPOSITORY=$(vault kv get -field=repository kv/homeserver/github)
        GITHUB_RUNNER_TOKEN=$(vault kv get -field=runner_token kv/homeserver/github)
        RUNNER_NAME=$(vault kv get -field=RUNNER_NAME kv/homeserver/config)
        
        # Static Configuration (from config)
        PLEX_PORT=32400
        QBITTORRENT_PORT=8080
        GRAFANA_PORT=3000
        PROMETHEUS_PORT=9090
        TEAMSPEAK_VOICE_PORT=9987
        TEAMSPEAK_QUERY_PORT=10011
        TEAMSPEAK_FILES_PORT=30033
        CS2_PORT=27015
        CS2_RCON_PORT=27025
        PLEX_MEMORY_LIMIT=8g
        PLEX_CPU_LIMIT=6
        CS2_MEMORY_LIMIT=4g
        CS2_CPU_LIMIT=4
        MARIADB_MEMORY_LIMIT=2g
        REDIS_MEMORY_LIMIT=256m
        LOG_LEVEL=info
        BACKUP_SCHEDULE="0 2 * * *"
        UPDATE_CHECK_SCHEDULE="0 6 * * 0"
        RUNNER_GROUP=default
        RUNNER_EPHEMERAL=false
        RUNNER_MEMORY_LIMIT=2g
        RUNNER_MEMORY_RESERVATION=1g
        RUNNER_CPU_LIMIT=2.0
        PROJECT_PATH=$(vault kv get -field=PROJECT_PATH kv/homeserver/config)
        DEVELOPMENT_MODE=false
        DEBUG_LOGGING=false
        EOF
        
        # Set proper permissions
        chmod 600 .env
        
        echo "Successfully generated .env from Vault secrets"
    
    - name: Validate Generated Secrets
      run: |
        echo "Validating generated .env file..."
        
        # Check that required variables are present
        required_vars=(
          "DOMAIN"
          "MYSQL_ROOT_PASSWORD" 
          "REDIS_PASSWORD"
          "GF_SECURITY_ADMIN_PASSWORD"
        )
        
        for var in "${required_vars[@]}"; do
          if ! grep -q "^${var}=" .env; then
            echo "ERROR: Required variable $var not found in .env"
            exit 1
          fi
          
          # Check that value is not placeholder
          value=$(grep "^${var}=" .env | cut -d'=' -f2-)
          if [[ "$value" =~ (CHANGE_ME|your_|placeholder) ]]; then
            echo "WARNING: Variable $var appears to have placeholder value: $value"
          fi
        done
        
        echo "Secret validation completed"

  rotate-github-token:
    name: Rotate GitHub Runner Token
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      contents: read
      actions: read
    needs: vault-auth
    if: github.event.inputs.action == 'rotate-github-runner-token'
    
    steps:
    - name: Generate New Runner Token
      id: token
      run: |
        echo "Generating new GitHub runner token..."
        
        response=$(curl -s -X POST \
          -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/${{ github.repository }}/actions/runners/registration-token")
        
        token=$(echo "$response" | jq -r '.token')
        
        if [[ "$token" == "null" || -z "$token" ]]; then
          echo "Failed to generate runner token"
          exit 1
        fi
        
        echo "token=$token" >> $GITHUB_OUTPUT
        echo "Successfully generated new runner token"
    
    - name: Update Token in Vault
      env:
        VAULT_TOKEN: ${{ needs.vault-auth.outputs.vault-token }}
      run: |
        echo "Updating GitHub runner token in Vault..."
        
        vault kv patch kv/homeserver/github \
          runner_token="${{ steps.token.outputs.token }}"
        
        echo "GitHub runner token updated in Vault"

  validate-secrets:
    name: Validate Vault Secrets
    runs-on: self-hosted  
    timeout-minutes: 5
    permissions:
      contents: read
    needs: vault-auth
    if: github.event.inputs.action == 'validate-secrets'
    
    steps:
    - name: Validate Secret Paths
      env:
        VAULT_TOKEN: ${{ needs.vault-auth.outputs.vault-token }}
      run: |
        echo "Validating Vault secret paths..."
        
        required_paths=(
          "kv/homeserver/config"
          "kv/homeserver/database"
          "kv/homeserver/services"
          "kv/homeserver/authelia"
          "kv/homeserver/cloudflare"
          "kv/homeserver/notifications"
          "kv/homeserver/backup"
          "kv/homeserver/github"
        )
        
        failed_paths=()
        
        for path in "${required_paths[@]}"; do
          if vault kv get "$path" >/dev/null 2>&1; then
            echo "✓ $path exists"
          else
            echo "✗ $path missing"
            failed_paths+=("$path")
          fi
        done
        
        if [[ ${#failed_paths[@]} -gt 0 ]]; then
          echo "ERROR: Missing secret paths: ${failed_paths[*]}"
          exit 1
        fi
        
        echo "All required secret paths exist in Vault"