defmodule Mix.Tasks.Romulus.AnsibleInventory do
  @moduledoc """
  Generate Ansible inventory from current infrastructure state.
  
  Usage:
    mix romulus.ansible_inventory [--format yaml|ini] [--output path]
  """
  
  use Mix.Task
  
  alias Romulus.Core.{State, Config}
  
  @shortdoc "Generate Ansible inventory"
  
  def run(args) do
    Application.ensure_all_started(:romulus_elixir)
    
    {opts, _, _} = OptionParser.parse(args,
      switches: [format: :string, output: :string],
      aliases: [f: :format, o: :output]
    )
    
    format = Keyword.get(opts, :format, "yaml")
    output = Keyword.get(opts, :output, nil)
    
    case generate_inventory(format) do
      {:ok, inventory} ->
        if output do
          File.write!(output, inventory)
          Mix.shell().info("✅ Inventory written to #{output}")
        else
          IO.puts(inventory)
        end
        
      {:error, reason} ->
        Mix.shell().error("❌ Failed to generate inventory: #{reason}")
        exit({:shutdown, 1})
    end
  end
  
  defp generate_inventory(format) do
    with {:ok, config} <- Romulus.Core.Config.load("romulus.yaml"),
         {:ok, state} <- Romulus.Core.State.fetch_current() do
      
      inventory = build_inventory(config, state)
      
      case format do
        "yaml" -> {:ok, format_yaml(inventory)}
        "ini" -> {:ok, format_ini(inventory)}
        _ -> {:error, "Unknown format: #{format}"}
      end
    end
  end
  
  defp build_inventory(config, state) do
    nodes = config[:nodes]
    ssh = config[:ssh]
    
    # Get actual IPs from running domains or use configured IPs
    masters = for i <- 1..nodes[:masters][:count] do
      name = "k8s-master-#{i}"
      domain = Enum.find(state.domains, & &1.name == name)
      
      %{
        name: name,
        ip: domain && domain.ip_address || "#{nodes[:masters][:ip_prefix]}#{i}",
        ansible_host: domain && domain.ip_address || "#{nodes[:masters][:ip_prefix]}#{i}",
        ansible_user: ssh[:user] || "debian",
        ansible_ssh_private_key_file: ssh[:private_key_path] || "~/.ssh/id_rsa",
        node_type: "master"
      }
    end
    
    workers = for i <- 1..nodes[:workers][:count] do
      name = "k8s-worker-#{i}"
      domain = Enum.find(state.domains, & &1.name == name)
      
      %{
        name: name,
        ip: domain && domain.ip_address || "#{nodes[:workers][:ip_prefix]}#{i}",
        ansible_host: domain && domain.ip_address || "#{nodes[:workers][:ip_prefix]}#{i}",
        ansible_user: ssh[:user] || "debian",
        ansible_ssh_private_key_file: ssh[:private_key_path] || "~/.ssh/id_rsa",
        node_type: "worker"
      }
    end
    
    %{
      all: %{
        vars: %{
          ansible_python_interpreter: "/usr/bin/python3",
          ansible_ssh_common_args: "-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null",
          cluster_name: config[:cluster][:name],
          cluster_domain: config[:cluster][:domain],
          kubernetes_version: config[:kubernetes][:version] || "1.28",
          pod_subnet: config[:kubernetes][:pod_subnet] || "10.244.0.0/16",
          service_subnet: config[:kubernetes][:service_subnet] || "10.96.0.0/12"
        },
        children: ["masters", "workers", "k8s_cluster"]
      },
      masters: %{
        hosts: Map.new(masters, fn m -> {m.name, Map.delete(m, :name)} end)
      },
      workers: %{
        hosts: Map.new(workers, fn w -> {w.name, Map.delete(w, :name)} end)
      },
      k8s_cluster: %{
        children: ["masters", "workers"]
      }
    }
  end
  
  @doc false
  @spec format_yaml(map()) :: String.t()
  defp format_yaml(inventory) do
    vars = inventory.all.vars
    """
    # Ansible Inventory (YAML) - Generated by Romulus Elixir Backend
    # Generated at: #{vars.generated_at}
    # Cluster: #{vars.cluster_name}
    
    all:
      vars:
        # Connection settings
        ansible_python_interpreter: "#{vars.ansible_python_interpreter}"
        ansible_ssh_common_args: "#{vars.ansible_ssh_common_args}"
        
        # Cluster configuration
        cluster_name: "#{vars.cluster_name}"
        cluster_domain: "#{vars.cluster_domain}"
        
        # Kubernetes settings
        kubernetes_version: "#{vars.kubernetes_version}"
        pod_subnet: "#{vars.pod_subnet}"
        service_subnet: "#{vars.service_subnet}"
        
        # Runtime metadata
        generated_at: "#{vars.generated_at}"
        romulus_backend: "#{vars.romulus_backend}"
      
      children:
        - masters
        - workers
        - k8s_cluster
    
    masters:
      hosts:
#{format_yaml_hosts(inventory.masters.hosts, "        ")}
    
    workers:
      hosts:
#{format_yaml_hosts(inventory.workers.hosts, "        ")}
    
    k8s_cluster:
      children:
        - masters
        - workers
    """
  end
  
  @doc false
  @spec format_yaml_hosts(map(), String.t()) :: String.t()
  defp format_yaml_hosts(hosts, indent) when map_size(hosts) == 0 do
    "#{indent}# No hosts configured"
  end
  
  defp format_yaml_hosts(hosts, indent) do
    hosts
    |> Enum.sort_by(fn {name, _} -> name end)
    |> Enum.map(fn {name, vars} ->
      # Build host entry with available information
      base_vars = [
        "ansible_host: \"#{vars.ansible_host}\"",
        "ansible_user: \"#{vars.ansible_user}\"",
        "ansible_ssh_private_key_file: \"#{vars.ansible_ssh_private_key_file}\"",
        "node_type: \"#{vars.node_type}\""
      ]
      
      # Add optional variables if available
      optional_vars = []
      optional_vars = if Map.has_key?(vars, :domain_state) and vars.domain_state != :unknown do
        ["domain_state: \"#{vars.domain_state}\"" | optional_vars]
      else
        optional_vars
      end
      optional_vars = if Map.has_key?(vars, :memory) and vars.memory do
        ["memory_mb: #{vars.memory}" | optional_vars]
      else
        optional_vars
      end
      optional_vars = if Map.has_key?(vars, :vcpu) and vars.vcpu do
        ["vcpu_count: #{vars.vcpu}" | optional_vars]
      else
        optional_vars
      end
      
      all_vars = base_vars ++ Enum.reverse(optional_vars)
      
      var_lines = all_vars
      |> Enum.map(&"#{indent}  #{&1}")
      |> Enum.join("\n")
      
      "#{indent}#{name}:\n#{var_lines}"
    end)
    |> Enum.join("\n\n")
  end
  
  @doc false
  @spec format_ini(map()) :: String.t()
  defp format_ini(inventory) do
    vars = inventory.all.vars
    """
    # Ansible Inventory (INI format) - Generated by Romulus Elixir Backend
    # Generated at: #{vars.generated_at}
    # Cluster: #{vars.cluster_name}
    
    [all:vars]
    # Connection settings
    ansible_python_interpreter=#{vars.ansible_python_interpreter}
    ansible_ssh_common_args=#{vars.ansible_ssh_common_args}
    
    # Cluster configuration
    cluster_name=#{vars.cluster_name}
    cluster_domain=#{vars.cluster_domain}
    
    # Kubernetes settings
    kubernetes_version=#{vars.kubernetes_version}
    pod_subnet=#{vars.pod_subnet}
    service_subnet=#{vars.service_subnet}
    
    # Runtime metadata
    generated_at=#{vars.generated_at}
    romulus_backend=#{vars.romulus_backend}
    
    [masters]
#{format_ini_hosts(inventory.masters.hosts)}
    
    [workers]
#{format_ini_hosts(inventory.workers.hosts)}
    
    [k8s_cluster:children]
    masters
    workers
    
    # Individual node groups for fine-grained control
#{format_ini_node_groups(inventory)}
    """
  end
  
  @doc false
  @spec format_ini_hosts(map()) :: String.t()
  defp format_ini_hosts(hosts) when map_size(hosts) == 0 do
    "# No hosts configured"
  end
  
  defp format_ini_hosts(hosts) do
    hosts
    |> Enum.sort_by(fn {name, _} -> name end)
    |> Enum.map(fn {name, vars} ->
      # Build parameter list with essential connection info
      base_params = [
        "ansible_host=#{vars.ansible_host}",
        "ansible_user=#{vars.ansible_user}",
        "ansible_ssh_private_key_file=#{vars.ansible_ssh_private_key_file}",
        "node_type=#{vars.node_type}"
      ]
      
      # Add optional parameters if available
      optional_params = []
      optional_params = if Map.has_key?(vars, :domain_state) and vars.domain_state != :unknown do
        ["domain_state=#{vars.domain_state}" | optional_params]
      else
        optional_params
      end
      optional_params = if Map.has_key?(vars, :memory) and vars.memory do
        ["memory_mb=#{vars.memory}" | optional_params]
      else
        optional_params
      end
      optional_params = if Map.has_key?(vars, :vcpu) and vars.vcpu do
        ["vcpu_count=#{vars.vcpu}" | optional_params]
      else
        optional_params
      end
      
      all_params = base_params ++ Enum.reverse(optional_params)
      params_str = Enum.join(all_params, " ")
      
      "#{name} #{params_str}"
    end)
    |> Enum.join("\n")
  end
  
  @doc false
  @spec format_ini_node_groups(map()) :: String.t()
  defp format_ini_node_groups(inventory) do
    master_names = Map.keys(inventory.masters.hosts) |> Enum.sort()
    worker_names = Map.keys(inventory.workers.hosts) |> Enum.sort()
    
    groups = []
    
    # Add first master group for init operations
    groups = if length(master_names) > 0 do
      ["[kube_control_plane]\n#{Enum.join(master_names, "\n")}" | groups]
    else
      groups
    end
    
    # Add etcd group (typically same as masters)
    groups = if length(master_names) > 0 do
      ["[etcd]\n#{Enum.join(master_names, "\n")}" | groups]
    else
      groups
    end
    
    # Add kube node group (all nodes)
    all_nodes = master_names ++ worker_names
    groups = if length(all_nodes) > 0 do
      ["[kube_node]\n#{Enum.join(all_nodes, "\n")}" | groups]
    else
      groups
    end
    
    if length(groups) > 0 do
      Enum.reverse(groups) |> Enum.join("\n\n")
    else
      "# No additional node groups"
    end
  end
end