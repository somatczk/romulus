defmodule Romulus.Operations.Executor do
  @moduledoc """
  Executes infrastructure plans by applying changes to libvirt resources.

  This module takes a plan (list of actions) generated by the Planner
  and executes each action in dependency order. It handles resource
  creation, updates, and destruction while maintaining proper error
  handling and rollback capabilities.

  ## Supported Actions

  - **Create**: Storage pools, networks, volumes, cloud-init ISOs, domains
  - **Destroy**: Domains, volumes, networks, storage pools
  - **Update**: Configuration changes (future enhancement)

  ## Dependencies

  Actions are executed in proper dependency order:
  1. Storage pools (create first, destroy last)
  2. Networks
  3. Volumes and cloud-init ISOs
  4. Virtual machine domains

  ## Error Handling

  The executor stops on first failure and returns detailed error
  information. This ensures infrastructure remains in a consistent
  state and prevents cascading failures.

  ## Examples

      iex> plan = [%Action{type: :create, resource_type: :pool, resource: pool}]
      iex> {:ok, :success} = Executor.execute(plan)

      iex> {:error, reason} = Executor.execute(invalid_plan)

  """

  alias Romulus.Core.{Planner, State}
  alias Romulus.{Error, Infra.Libvirt, CloudInit}

  require Logger

  @type execution_result :: {:ok, :success | :skipped} | {:error, term()}
  @type action_result :: {:ok, term()} | {:error, term()}
  
  @doc """
  Executes a complete infrastructure plan by applying all actions in order.

  Takes a list of actions from the planner and executes them sequentially.
  Actions are processed in dependency order to ensure proper resource
  creation and destruction.

  ## Parameters

    * `plan` - List of `Planner.Action` structs to execute

  ## Returns

    * `{:ok, :success}` - All actions executed successfully
    * `{:error, reason}` - Execution failed, contains error details

  ## Behavior

  - Stops execution on first failure (fail-fast)
  - Logs progress and errors for debugging
  - Returns accumulated results for successful actions
  - Maintains infrastructure consistency by preventing partial updates

  ## Examples

      iex> plan = Planner.create_plan(current_state, desired_state)
      iex> {:ok, :success} = Executor.execute(plan)

      iex> {:error, "Failed to create network: already exists"} = Executor.execute(invalid_plan)

  """
  @spec execute([Planner.Action.t()]) :: execution_result()
  def execute(plan) when is_list(plan) do
    Logger.info("Starting execution of plan with #{length(plan)} actions")
    
    results = Enum.reduce_while(plan, {:ok, []}, fn action, {:ok, acc} ->
      case execute_action(action) do
        {:ok, result} ->
          {:cont, {:ok, acc ++ [result]}}
          
        {:error, reason} = error ->
          Logger.error("Failed to execute action: #{inspect(reason)}")
          {:halt, error}
      end
    end)
    
    case results do
      {:ok, _} ->
        Logger.info("Plan executed successfully - all #{length(plan)} actions completed")
        {:ok, :success}
        
      error ->
        error
    end
  end
  
  @spec execute_action(Planner.Action.t()) :: action_result()
  defp execute_action(%Planner.Action{} = action) do
    resource_name = extract_resource_name(action.resource)
    Logger.info("Executing #{action.type} for #{action.resource_type}: #{resource_name}")

    try do
      result = dispatch_action(action)
      log_action_success(action, resource_name)
      result
    rescue
      error ->
        log_action_error(action, resource_name, error)
        {:error, "Failed to #{action.type} #{action.resource_type} '#{resource_name}': #{Exception.message(error)}"}
    end
  end

  # Dispatches action to appropriate libvirt operation
  @spec dispatch_action(Planner.Action.t()) :: action_result()
  defp dispatch_action(%Planner.Action{type: type, resource_type: resource_type} = action) do
    case {type, resource_type} do
      {:create, :pool} ->
        Libvirt.create_pool(action.resource)

      {:create, :network} ->
        Libvirt.create_network(action.resource)

      {:create, :volume} ->
        Libvirt.create_volume(action.resource)

      {:create, :cloudinit} ->
        create_cloudinit_iso(action.resource)

      {:create, :domain} ->
        Libvirt.create_domain(action.resource)

      {:destroy, :domain} ->
        Libvirt.delete_domain(action.resource.name)

      {:destroy, :volume} ->
        Libvirt.delete_volume(action.resource.name, action.resource.pool)

      {:destroy, :network} ->
        Libvirt.delete_network(action.resource.name)

      {:destroy, :pool} ->
        Libvirt.delete_pool(action.resource.name)

      {:update, resource_type} ->
        handle_update_action(action, resource_type)

      _ ->
        Logger.warning("Unsupported action combination: #{type} #{resource_type}")
        {:ok, :skipped}
    end
  end
  
  # Handles update actions (future enhancement)
  @spec handle_update_action(Planner.Action.t(), atom()) :: action_result()
  defp handle_update_action(_action, resource_type) do
    Logger.info("Update operations for #{resource_type} not yet implemented")
    {:ok, :skipped}
  end

  @spec create_cloudinit_iso(map()) :: action_result()
  defp create_cloudinit_iso(%{vm: vm, config: config}) do
    with {:ok, node_type} <- extract_node_type(vm),
         {:ok, node_index} <- extract_node_index(vm.name),
         {:ok, cloudinit_data} <- generate_cloudinit_data(node_type, node_index, config),
         {:ok, iso_path} <- create_iso_file(vm, cloudinit_data) do
      Logger.info("Cloud-init ISO created successfully", iso_path: iso_path, vm: vm.name)
      {:ok, iso_path}
    else
      {:error, reason} ->
        Logger.error("Failed to create cloud-init ISO for #{vm.name}", error: reason)
        {:error, reason}
    end
  end

  # Utility functions for better code organization and error handling

  @spec extract_resource_name(term()) :: String.t()
  defp extract_resource_name(resource) do
    case resource do
      %{name: name} when is_binary(name) -> name
      %{vm: %{name: name}} when is_binary(name) -> name
      _ -> "unknown"
    end
  end

  @spec extract_node_type(map()) :: {:ok, atom()} | {:error, String.t()}
  defp extract_node_type(%{type: type}) when is_atom(type), do: {:ok, type}
  defp extract_node_type(%{type: type}) when is_binary(type), do: {:ok, String.to_atom(type)}
  defp extract_node_type(_), do: {:error, "Invalid or missing node type"}

  @spec extract_node_index(String.t()) :: {:ok, integer()} | {:error, String.t()}
  defp extract_node_index(vm_name) when is_binary(vm_name) do
    case vm_name |> String.split("-") |> List.last() |> Integer.parse() do
      {index, ""} -> {:ok, index}
      _ -> {:error, "Cannot extract node index from VM name: #{vm_name}"}
    end
  end
  defp extract_node_index(_), do: {:error, "Invalid VM name format"}

  @spec generate_cloudinit_data(atom(), integer(), map()) :: {:ok, map()} | {:error, String.t()}
  defp generate_cloudinit_data(node_type, node_index, config) do
    case CloudInit.Renderer.generate_node_cloudinit(node_type, node_index, config) do
      {:ok, data} -> {:ok, data}
      {:error, reason} -> {:error, "Cloud-init generation failed: #{reason}"}
    end
  end

  @spec create_iso_file(map(), map()) :: {:ok, String.t()} | {:error, String.t()}
  defp create_iso_file(vm, cloudinit_data) do
    CloudInit.Renderer.create_cloudinit_iso(
      vm.name,
      vm.pool,
      cloudinit_data.user_data,
      cloudinit_data.network_config
    )
  end

  @spec log_action_success(Planner.Action.t(), String.t()) :: :ok
  defp log_action_success(action, resource_name) do
    Logger.info("Successfully #{action.type}d #{action.resource_type}",
      resource_type: action.resource_type,
      action: action.type,
      resource: resource_name
    )
  end

  @spec log_action_error(Planner.Action.t(), String.t(), Exception.t()) :: :ok
  defp log_action_error(action, resource_name, error) do
    Logger.error("Failed to #{action.type} #{action.resource_type}",
      resource_type: action.resource_type,
      action: action.type,
      resource: resource_name,
      error: Exception.message(error)
    )
  end
  
  @doc """
  Execute a plan with options for different execution modes.
  """
  @spec execute([Planner.Action.t()], keyword()) :: execution_result()
  def execute(plan, opts \\ []) when is_list(plan) do
    mode = Keyword.get(opts, :mode, :sequential)
    dry_run = Keyword.get(opts, :dry_run, false)
    on_error = Keyword.get(opts, :on_error, :halt)
    rollback_on_error = Keyword.get(opts, :rollback_on_error, false)
    
    cond do
      dry_run ->
        execute_dry_run(plan)
      mode == :parallel ->
        execute_parallel(plan, opts)
      on_error == :continue ->
        execute_continue_on_error(plan, opts)
      rollback_on_error ->
        execute_with_rollback(plan, opts)
      true ->
        execute(plan)
    end
  end
  
  @doc """
  Validate a plan before execution.
  """
  @spec validate_plan_before_execution([Planner.Action.t()]) :: {:ok, [Planner.Action.t()]} | {:error, String.t()}
  def validate_plan_before_execution(plan) when is_list(plan) do
    with :ok <- validate_action_structure(plan),
         :ok <- validate_resource_availability(plan) do
      {:ok, plan}
    end
  end
  
  @doc """
  Get execution summary after completion.
  """
  @spec get_execution_summary() :: map()
  def get_execution_summary do
    # This would typically be stored in process state or ETS table
    %{
      total_actions: 0,
      successful_actions: 0,
      failed_actions: 0,
      skipped_actions: 0,
      execution_time_seconds: 0,
      errors: []
    }
  end
  
  # Execution mode implementations
  
  defp execute_dry_run(plan) do
    Logger.info("Executing dry run for #{length(plan)} actions")
    
    Enum.each(plan, fn action ->
      resource_name = extract_resource_name(action.resource)
      Logger.info("[DRY RUN] Would execute #{action.type} for #{action.resource_type}: #{resource_name}")
    end)
    
    {:ok, :dry_run_complete}
  end
  
  defp execute_parallel(plan, _opts) do
    Logger.info("Starting parallel execution of plan with #{length(plan)} actions")
    
    # Group actions by dependency level for parallel execution
    dependency_groups = group_by_dependencies(plan)
    
    results = Enum.reduce_while(dependency_groups, {:ok, []}, fn group, {:ok, acc} ->
      # Execute each dependency group in parallel
      group_results = 
        group
        |> Task.async_stream(&execute_action/1, max_concurrency: 4, timeout: 30_000)
        |> Enum.map(fn {:ok, result} -> result end)
      
      case Enum.find(group_results, fn result -> match?({:error, _}, result) end) do
        nil ->
          {:cont, {:ok, acc ++ group_results}}
        error ->
          {:halt, error}
      end
    end)
    
    case results do
      {:ok, _} ->
        Logger.info("Parallel execution completed successfully")
        {:ok, :success}
      error ->
        error
    end
  end
  
  defp execute_continue_on_error(plan, _opts) do
    Logger.info("Starting execution with continue-on-error mode")
    
    results = Enum.map(plan, fn action ->
      case execute_action(action) do
        {:ok, result} -> {:ok, result}
        {:error, reason} ->
          Logger.warning("Action failed but continuing: #{reason}")
          {:error, reason}
      end
    end)
    
    errors = Enum.filter(results, &match?({:error, _}, &1))
    
    if Enum.empty?(errors) do
      {:ok, :success}
    else
      {:ok, :partial_success}
    end
  end
  
  defp execute_with_rollback(plan, _opts) do
    Logger.info("Starting execution with rollback capability")
    
    {_executed_actions, result} = Enum.reduce_while(plan, {[], {:ok, []}}, fn action, {executed, {:ok, acc}} ->
      case execute_action(action) do
        {:ok, result} ->
          {:cont, {[action | executed], {:ok, acc ++ [result]}}}
        {:error, reason} = error ->
          Logger.error("Action failed, initiating rollback: #{reason}")
          rollback_actions(executed)
          {:halt, {executed, error}}
      end
    end)
    
    case result do
      {:ok, _} ->
        Logger.info("Execution completed successfully")
        {:ok, :success}
      error ->
        error
    end
  end
  
  # Helper functions
  
  defp validate_action_structure(plan) do
    invalid_action = Enum.find(plan, fn action ->
      case action do
        %Planner.Action{type: type, resource_type: _, resource: resource}
          when type in [:create, :update, :destroy] and not is_nil(resource) ->
          false
        _ ->
          true
      end
    end)
    
    case invalid_action do
      nil -> :ok
      action -> {:error, "Invalid action structure: #{inspect(action)}"}
    end
  end
  
  defp validate_resource_availability(_plan) do
    # Placeholder for resource availability checks
    :ok
  end
  
  defp group_by_dependencies(plan) do
    # Group actions by dependency level for parallel execution
    dependency_levels = %{
      pool: 1,
      network: 2, 
      volume: 3,
      domain: 4
    }
    
    plan
    |> Enum.group_by(fn action -> Map.get(dependency_levels, action.resource_type, 5) end)
    |> Map.values()
  end
  
  defp rollback_actions(executed_actions) do
    Logger.info("Rolling back #{length(executed_actions)} executed actions")
    
    # Reverse the order and create opposite actions
    executed_actions
    |> Enum.reverse()
    |> Enum.each(fn action ->
      rollback_action = create_rollback_action(action)
      case execute_action(rollback_action) do
        {:ok, _} ->
          Logger.info("Successfully rolled back #{action.resource_type}: #{extract_resource_name(action.resource)}")
        {:error, reason} ->
          Logger.error("Failed to rollback #{action.resource_type}: #{reason}")
      end
    end)
  end
  
  defp create_rollback_action(%Planner.Action{type: :create} = action) do
    %Planner.Action{
      type: :destroy,
      resource_type: action.resource_type,
      resource: action.resource,
      reason: "Rollback of failed creation"
    }
  end
  
  defp create_rollback_action(%Planner.Action{type: :destroy} = action) do
    %Planner.Action{
      type: :create,
      resource_type: action.resource_type,
      resource: action.resource,
      reason: "Rollback of failed destruction"
    }
  end
  
  defp create_rollback_action(action), do: action
end
