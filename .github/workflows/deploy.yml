name: Deploy Homeserver

on:
  push:
    branches: [ master ]
  workflow_dispatch:

concurrency:
  group: deploy
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  deploy:
    name: Deploy Infrastructure
    runs-on: self-hosted
    timeout-minutes: 29
    
    steps:
    - name: Clean Previous Run Files
      run: |
        # Fix permissions on any files from previous runs that might block checkout
        sudo chown -R $USER:$USER . || true
        sudo chmod -R u+w . || true
        # Remove any problematic directories
        sudo rm -rf compose/core/configs/ || true

    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        clean: true

    # Decrypt environment secrets from encrypted JSON file
    - name: Decrypt Environment Secrets
      run: ./scripts/decrypt-large-secrets.sh homeserver-env-secrets.json
      env:
        LARGE_SECRET_PASSPHRASE_HOMESERVER_ENV_SECRETS_JSON: ${{ secrets.ENV_SECRETS_PASSPHRASE }}

    # Verify and prepare environment variables from the decrypted JSON file
    - name: Prepare Environment Variables
      run: |
        # Verify the JSON file exists and is valid
        if [ ! -f "$HOME/secrets/homeserver-env-secrets.json" ]; then
          echo "::error::Environment secrets file not found"
          exit 1
        fi
        
        # Validate JSON format
        if ! jq empty "$HOME/secrets/homeserver-env-secrets.json" 2>/dev/null; then
          echo "::error::Invalid JSON format in environment secrets"
          exit 1
        fi
        
        # Count loaded variables (for verification)
        VARIABLE_COUNT=$(jq 'keys | length' "$HOME/secrets/homeserver-env-secrets.json")
        echo "::notice::Environment file contains $VARIABLE_COUNT variables"
        
        # Verify critical variables are present (without exposing values)
        CRITICAL_VARS=("DOMAIN" "CLOUDFLARE_API_TOKEN" "MYSQL_ROOT_PASSWORD" "REDIS_PASSWORD")
        for var in "${CRITICAL_VARS[@]}"; do
          if jq -e "has(\"$var\")" "$HOME/secrets/homeserver-env-secrets.json" >/dev/null; then
            echo "::notice::Critical variable $var verified"
          else
            echo "::error::Critical variable $var is missing"
            exit 1
          fi
        done

    - name: Validate Configuration
      run: |
        # Load environment variables for this step only
        export $(jq -r 'to_entries[] | "\(.key)=\(.value)"' "$HOME/secrets/homeserver-env-secrets.json" | xargs)
        docker-compose config --quiet

    - name: Create Required Directories
      run: |
        # Load environment variables for this step only
        export $(jq -r 'to_entries[] | "\(.key)=\(.value)"' "$HOME/secrets/homeserver-env-secrets.json" | xargs)
        # Clean up any incorrectly created directories first
        sudo rm -rf "${SSD_PATH}/config" || true
        
        # Create application directories (removed config/{...} that was conflicting with Caddy)
        sudo mkdir -p "${SSD_PATH}"/{caddy/{data,config},databases/{mariadb,redis},monitoring/{prometheus,grafana,loki,alertmanager,uptime-kuma}}
        sudo mkdir -p "${NVME_PATH}/games/cs2"
        sudo mkdir -p "${HDD_PATH}"/{media,downloads/complete}
        
        # Set proper ownership from the start
        sudo chown -R "${PUID}:${PGID}" "${SSD_PATH}" "${NVME_PATH}" "${HDD_PATH}" || true
        # Ensure the runner user can also access these directories
        sudo chmod -R u+rwx,g+rwx "${SSD_PATH}" "${NVME_PATH}" "${HDD_PATH}" || true

    - name: Set Container-Specific Permissions
      run: |
        # Load environment variables for this step only
        export $(jq -r 'to_entries[] | "\(.key)=\(.value)"' "$HOME/secrets/homeserver-env-secrets.json" | xargs)
        echo "Setting container-specific directory permissions..."
        # Set permissions for monitoring services with their specific user IDs
        sudo chown -R 472:472 "${SSD_PATH}/monitoring/grafana" || true
        sudo chown -R 65534:65534 "${SSD_PATH}/monitoring/prometheus" || true
        sudo chown -R 10001:10001 "${SSD_PATH}/monitoring/loki" || true
        sudo chown -R 65534:65534 "${SSD_PATH}/monitoring/alertmanager" || true
        sudo chown -R root:root "${SSD_PATH}/monitoring/uptime-kuma" || true
        sudo chown -R root:root "${SSD_PATH}/monitoring/fail2ban" || true
        echo "Container permissions set successfully"

    - name: Deploy Core Infrastructure
      run: |
        # Load environment variables for this step only
        export $(jq -r 'to_entries[] | "\(.key)=\(.value)"' "$HOME/secrets/homeserver-env-secrets.json" | xargs)
        echo "Stopping existing core infrastructure containers..."
        docker-compose stop caddy cloudflare-ddns mariadb redis || true
        docker-compose rm -f caddy cloudflare-ddns mariadb redis || true
        
        echo "Deploying core infrastructure services..."
        docker-compose up -d caddy cloudflare-ddns mariadb redis
        
        echo "Waiting for core services..."
        sleep 30
        
        docker-compose ps mariadb | grep -q "Up" || exit 1
        docker-compose ps redis | grep -q "Up" || exit 1

    - name: Deploy Application Services  
      run: |
        # Load environment variables for this step only
        export $(jq -r 'to_entries[] | "\(.key)=\(.value)"' "$HOME/secrets/homeserver-env-secrets.json" | xargs)
        echo "Stopping existing application services..."
        docker-compose stop plex qbittorrent teamspeak cs2-server || true
        docker-compose rm -f plex qbittorrent teamspeak cs2-server || true
        
        echo "Deploying application services..."
        docker-compose up -d plex qbittorrent teamspeak cs2-server
        sleep 30

    # Create MySQL exporter configuration file
    - name: Create MySQL Exporter Configuration
      run: |
        # Load environment variables for this step only
        export $(jq -r 'to_entries[] | "\(.key)=\(.value)"' "$HOME/secrets/homeserver-env-secrets.json" | xargs)
        echo "Creating MySQL exporter .my.cnf configuration..."
        
        # Create the config directory if it doesn't exist
        mkdir -p configs/mariadb/
        
        # Create .my.cnf file with current environment variables
        echo "[client]" > configs/mariadb/exporter.my.cnf
        echo "user = monitoring" >> configs/mariadb/exporter.my.cnf
        echo "password = ${MONITORING_DB_PASSWORD}" >> configs/mariadb/exporter.my.cnf
        echo "host = mariadb" >> configs/mariadb/exporter.my.cnf
        echo "port = 3306" >> configs/mariadb/exporter.my.cnf
        
        # Set appropriate permissions (readable by container user)
        chmod 644 configs/mariadb/exporter.my.cnf
        echo "MySQL exporter configuration created successfully"

    - name: Deploy Monitoring Stack
      run: |
        # Load environment variables for this step only
        export $(jq -r 'to_entries[] | "\(.key)=\(.value)"' "$HOME/secrets/homeserver-env-secrets.json" | xargs)
        echo "Stopping existing monitoring services..."
        docker-compose stop prometheus grafana loki promtail alertmanager uptime-kuma node-exporter cadvisor redis-exporter mariadb-exporter blackbox-exporter || true
        docker-compose rm -f prometheus grafana loki promtail alertmanager uptime-kuma node-exporter cadvisor redis-exporter mariadb-exporter blackbox-exporter || true
        
        echo "Deploying monitoring services..."
        docker-compose up -d prometheus grafana loki promtail alertmanager uptime-kuma node-exporter cadvisor redis-exporter mariadb-exporter blackbox-exporter
        sleep 20

    - name: Deploy Security Services
      run: |
        # Load environment variables for this step only
        export $(jq -r 'to_entries[] | "\(.key)=\(.value)"' "$HOME/secrets/homeserver-env-secrets.json" | xargs)
        echo "Stopping existing security services..."
        docker-compose stop fail2ban || true
        docker-compose rm -f fail2ban || true
        
        echo "Deploying security services..."
        docker-compose up -d fail2ban
        sleep 10

    - name: Health Check
      run: |
        # Load environment variables for this step only
        export $(jq -r 'to_entries[] | "\(.key)=\(.value)"' "$HOME/secrets/homeserver-env-secrets.json" | xargs)
        echo "Performing health checks..."
        
        # Check core services
        for service in caddy mariadb redis; do
          echo "Checking $service..."
          timeout=60
          elapsed=0
          
          while [[ $elapsed -lt $timeout ]]; do
            case $service in
              caddy)
                if docker-compose ps "$service" | grep -q "Up"; then
                  echo "$service is running"
                  break
                fi
                ;;
              mariadb)
                if docker-compose ps "$service" | grep -q "Up"; then
                  echo "$service is running"
                  break
                fi
                ;;
              redis)
                if docker-compose ps "$service" | grep -q "Up"; then
                  echo "$service is running"
                  break
                fi
                ;;
            esac
            sleep 5
            elapsed=$((elapsed + 5))
          done
          
          if [[ $elapsed -ge $timeout ]]; then
            echo "$service failed to start"
            exit 1
          fi
        done
        
        # Check monitoring services
        for service in prometheus grafana; do
          echo "Checking $service..."
          if docker-compose ps "$service" | grep -q "Up"; then
            echo "$service is running"
          else
            echo "$service not running (non-critical)"
          fi
        done
        
        echo "All critical services are running"

    - name: Test External Access
      run: |
        # Load environment variables for this step only
        export $(jq -r 'to_entries[] | "\(.key)=\(.value)"' "$HOME/secrets/homeserver-env-secrets.json" | xargs)
        echo "Testing external access..."
        sleep 30
        
        endpoints=(
          "https://monitoring.${DOMAIN}/api/health"
          "https://status.${DOMAIN}"
        )
        
        for endpoint in "${endpoints[@]}"; do
          echo "Testing $endpoint..."
          if curl -f -s --max-time 30 --insecure "$endpoint" >/dev/null 2>&1; then
            echo "External endpoint accessible"
          else
            echo "External endpoint not accessible (may need more time)"
          fi
        done


    # Fix permissions for next run
    - name: Fix Permissions for Next Run
      if: always()
      run: |
        echo "Fixing permissions for next run..."
        # Fix ownership of any created files/directories
        sudo chown -R $USER:$USER . || true
        sudo chmod -R u+w . || true
        echo "Permissions fixed"

    - name: Deployment Summary
      run: |
        echo "Deployment completed successfully!"
        echo ""
        echo "Service Categories Deployed:"
        echo "  • Core Infrastructure (Proxy, Database, Cache)"
        echo "  • Media Services (Plex, qBittorrent)"
        echo "  • Gaming Services (TeamSpeak, CS2)"
        echo "  • Monitoring Stack (Prometheus, Grafana, Loki, Alerting, Uptime)"
        echo "  • Security Services (Fail2Ban)"
        echo ""
        echo "Configuration:"
        echo "  • All environment variables loaded from encrypted secrets"
        echo "  • Single passphrase authentication used"
        echo "  • Secure cleanup completed"