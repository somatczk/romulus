defmodule RomulusElixir.Executor do
  @moduledoc """
  Executes infrastructure plans by applying changes to libvirt resources.

  This module takes a plan (list of actions) generated by the Planner
  and executes each action in dependency order. It handles resource
  creation, updates, and destruction while maintaining proper error
  handling and rollback capabilities.

  ## Supported Actions

  - **Create**: Storage pools, networks, volumes, cloud-init ISOs, domains
  - **Destroy**: Domains, volumes, networks, storage pools
  - **Update**: Configuration changes (future enhancement)

  ## Dependencies

  Actions are executed in proper dependency order:
  1. Storage pools (create first, destroy last)
  2. Networks
  3. Volumes and cloud-init ISOs
  4. Virtual machine domains

  ## Error Handling

  The executor stops on first failure and returns detailed error
  information. This ensures infrastructure remains in a consistent
  state and prevents cascading failures.

  ## Examples

      iex> plan = [%Action{type: :create, resource_type: :pool, resource: pool}]
      iex> {:ok, :success} = Executor.execute(plan)

      iex> {:error, reason} = Executor.execute(invalid_plan)

  """

  alias RomulusElixir.{Libvirt, CloudInit, Planner}

  require Logger

  @type execution_result :: {:ok, :success | :skipped} | {:error, term()}
  @type action_result :: {:ok, term()} | {:error, term()}
  
  @doc """
  Executes a complete infrastructure plan by applying all actions in order.

  Takes a list of actions from the planner and executes them sequentially.
  Actions are processed in dependency order to ensure proper resource
  creation and destruction.

  ## Parameters

    * `plan` - List of `Planner.Action` structs to execute

  ## Returns

    * `{:ok, :success}` - All actions executed successfully
    * `{:error, reason}` - Execution failed, contains error details

  ## Behavior

  - Stops execution on first failure (fail-fast)
  - Logs progress and errors for debugging
  - Returns accumulated results for successful actions
  - Maintains infrastructure consistency by preventing partial updates

  ## Examples

      iex> plan = Planner.create_plan(current_state, desired_state)
      iex> {:ok, :success} = Executor.execute(plan)

      iex> {:error, "Failed to create network: already exists"} = Executor.execute(invalid_plan)

  """
  @spec execute([Planner.Action.t()]) :: execution_result()
  def execute(plan) when is_list(plan) do
    Logger.info("Starting execution of plan with #{length(plan)} actions")
    
    results = Enum.reduce_while(plan, {:ok, []}, fn action, {:ok, acc} ->
      case execute_action(action) do
        {:ok, result} ->
          {:cont, {:ok, acc ++ [result]}}
          
        {:error, reason} = error ->
          Logger.error("Failed to execute action: #{inspect(reason)}")
          {:halt, error}
      end
    end)
    
    case results do
      {:ok, _} ->
        Logger.info("Plan executed successfully - all #{length(plan)} actions completed")
        {:ok, :success}
        
      error ->
        error
    end
  end
  
  @spec execute_action(Planner.Action.t()) :: action_result()
  defp execute_action(%Planner.Action{} = action) do
    resource_name = extract_resource_name(action.resource)
    Logger.info("Executing #{action.type} for #{action.resource_type}: #{resource_name}")

    try do
      result = dispatch_action(action)
      log_action_success(action, resource_name)
      result
    rescue
      error ->
        log_action_error(action, resource_name, error)
        {:error, "Failed to #{action.type} #{action.resource_type} '#{resource_name}': #{Exception.message(error)}"}
    end
  end

  # Dispatches action to appropriate libvirt operation
  @spec dispatch_action(Planner.Action.t()) :: action_result()
  defp dispatch_action(%Planner.Action{type: type, resource_type: resource_type} = action) do
    case {type, resource_type} do
      {:create, :pool} ->
        Libvirt.create_pool(action.resource)

      {:create, :network} ->
        Libvirt.create_network(action.resource)

      {:create, :volume} ->
        Libvirt.create_volume(action.resource)

      {:create, :cloudinit} ->
        create_cloudinit_iso(action.resource)

      {:create, :domain} ->
        Libvirt.create_domain(action.resource)

      {:destroy, :domain} ->
        Libvirt.delete_domain(action.resource.name)

      {:destroy, :volume} ->
        Libvirt.delete_volume(action.resource.name, action.resource.pool)

      {:destroy, :network} ->
        Libvirt.delete_network(action.resource.name)

      {:destroy, :pool} ->
        Libvirt.delete_pool(action.resource.name)

      {:update, resource_type} ->
        handle_update_action(action, resource_type)

      _ ->
        Logger.warning("Unsupported action combination: #{type} #{resource_type}")
        {:ok, :skipped}
    end
  end
  
  # Handles update actions (future enhancement)
  @spec handle_update_action(Planner.Action.t(), atom()) :: action_result()
  defp handle_update_action(_action, resource_type) do
    Logger.info("Update operations for #{resource_type} not yet implemented")
    {:ok, :skipped}
  end

  @spec create_cloudinit_iso(map()) :: action_result()
  defp create_cloudinit_iso(%{vm: vm, config: config}) do
    with {:ok, node_type} <- extract_node_type(vm),
         {:ok, node_index} <- extract_node_index(vm.name),
         {:ok, cloudinit_data} <- generate_cloudinit_data(node_type, node_index, config),
         {:ok, iso_path} <- create_iso_file(vm, cloudinit_data) do
      Logger.info("Cloud-init ISO created successfully", iso_path: iso_path, vm: vm.name)
      {:ok, iso_path}
    else
      {:error, reason} ->
        Logger.error("Failed to create cloud-init ISO for #{vm.name}", error: reason)
        {:error, reason}
    end
  end

  # Utility functions for better code organization and error handling

  @spec extract_resource_name(term()) :: String.t()
  defp extract_resource_name(resource) do
    case resource do
      %{name: name} when is_binary(name) -> name
      %{vm: %{name: name}} when is_binary(name) -> name
      _ -> "unknown"
    end
  end

  @spec extract_node_type(map()) :: {:ok, atom()} | {:error, String.t()}
  defp extract_node_type(%{type: type}) when is_atom(type), do: {:ok, type}
  defp extract_node_type(%{type: type}) when is_binary(type), do: {:ok, String.to_atom(type)}
  defp extract_node_type(_), do: {:error, "Invalid or missing node type"}

  @spec extract_node_index(String.t()) :: {:ok, integer()} | {:error, String.t()}
  defp extract_node_index(vm_name) when is_binary(vm_name) do
    case vm_name |> String.split("-") |> List.last() |> Integer.parse() do
      {index, ""} -> {:ok, index}
      _ -> {:error, "Cannot extract node index from VM name: #{vm_name}"}
    end
  end
  defp extract_node_index(_), do: {:error, "Invalid VM name format"}

  @spec generate_cloudinit_data(atom(), integer(), map()) :: {:ok, map()} | {:error, String.t()}
  defp generate_cloudinit_data(node_type, node_index, config) do
    case CloudInit.Renderer.generate_node_cloudinit(node_type, node_index, config) do
      {:ok, data} -> {:ok, data}
      {:error, reason} -> {:error, "Cloud-init generation failed: #{reason}"}
    end
  end

  @spec create_iso_file(map(), map()) :: {:ok, String.t()} | {:error, String.t()}
  defp create_iso_file(vm, cloudinit_data) do
    CloudInit.Renderer.create_cloudinit_iso(
      vm.name,
      vm.pool,
      cloudinit_data.user_data,
      cloudinit_data.network_config
    )
  end

  @spec log_action_success(Planner.Action.t(), String.t()) :: :ok
  defp log_action_success(action, resource_name) do
    Logger.info("Successfully #{action.type}d #{action.resource_type}",
      resource_type: action.resource_type,
      action: action.type,
      resource: resource_name
    )
  end

  @spec log_action_error(Planner.Action.t(), String.t(), Exception.t()) :: :ok
  defp log_action_error(action, resource_name, error) do
    Logger.error("Failed to #{action.type} #{action.resource_type}",
      resource_type: action.resource_type,
      action: action.type,
      resource: resource_name,
      error: Exception.message(error)
    )
  end
end